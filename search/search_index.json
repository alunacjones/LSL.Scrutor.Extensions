{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#lslscrutorextensions","title":"LSL.Scrutor.Extensions","text":"<p>This package provides some extensions to Scrutor and Microsoft.Extensions.DependencyInjection.Abstractions </p> <p>The current library provides extensions for:</p> <p>NOTE: Some extension methods use Castle.Core and therefore the interfaces and classes used on each extension method must be public</p> Feature Uses Castle.Core? Auto Factories Yes Auto Registration No Intercepting Decorators Yes"},{"location":"Auto%20Factories/01-overview/","title":"Overview of auto factories","text":"<p>Auto factories allow us to define an interface that will be auto-implemented and thus save us writing a factory that has to resolve the created type's dependencies.</p> <p>This section provides examples of using the available methods.</p>"},{"location":"Auto%20Factories/concreteFactoryReturnType/","title":"A concrete factory return type","text":"<p>Assuming you have a definition for a factory interface as below:</p> <pre><code>public interface IMyFactoryForaConcreteType\n{\n    MyService Create(string name);\n}\n</code></pre> <p>and also a class definition of:</p> <pre><code>public class MyService : IMyService\n{\n    private readonly string _name;\n\n    public MyService(string name)\n    {\n        _name = name;\n    }\n\n    public string Name =&gt; _name.ToUpper();\n}\n</code></pre> <p>Then a factory implementation can be created with the following:</p> <pre><code>services.AddAutoFactory&lt;IMyFactoryForaConcreteType&gt;();\n</code></pre> <p>NOTE: The returned service from an <code>AddAutoFactory</code>'s  interface can have other  dependencies too as they will be automatically resolved.</p> <p>Any dependencies must be registered in the <code>IServiceCollection</code></p> <p>This factory can than be injected into other services to create instances of <code>MyService</code> using the factory interface.</p>"},{"location":"Auto%20Factories/concreteFactoryReturnType/#using-your-generated-factory","title":"Using your generated factory","text":"<pre><code>public class MyConsumer\n{\n    private readonly IMyFactoryForaConcreteType _factory;\n\n    public MyConsumer(IMyFactoryForaConcreteType factory)\n    {\n        _factory = factory;\n    }\n\n    public void DoSomething()\n    {\n        // `name` will have the value `A-NAME`\n        var name = _factory.Create(\"a-name\").Name;\n    }\n}\n</code></pre>"},{"location":"Auto%20Factories/interfaceReturnType/","title":"An interface for the factory return type","text":"<p>Assuming you have a definition for a factory interface as below:</p> <pre><code>public interface IMyFactory\n{\n    IMyService Create(string name);\n}\n</code></pre> <p>Then we need to further configure our auto factory so that it knows what concrete type to instantiate. This can be achieved as follows:</p> <pre><code>services.AddAutoFactory&lt;IMyFactory&gt;(c =&gt; c\n    .AddConcreteType&lt;IMyService, MyService&gt;()\n    .SetLifetime(ServiceLifetime.Scoped))\n</code></pre> <p>The code above configures the settings for the auto factory using the delegate we pass into the <code>AddAutoFactory</code> call.</p> <p>In this instance we are also electing to call the optional <code>SetLifeTime</code>  method to set the <code>ServiceLifetime</code> for the registered factory.</p> <p>NOTE: The default lifetime for a factory is <code>Singleton</code></p>"},{"location":"Auto%20Registration/01-overview/","title":"Overview of auto registration","text":"<p>The auto registration methods will automatically register all concrete classes that implement one of the following interfaces:</p> Interface Registered Lifetime <code>IScopedService</code> <code>ServiceLifetime.Scoped</code> <code>ISingletonService</code> <code>ServiceLifetime.Singleton</code> <code>ITransientService</code> <code>ServiceLifetime.Transient</code> <p>Note</p> <p>All of these interfaces live in the <code>LSL.Scrutor.Extensions</code> namespace.</p> <p>Warning</p> <p>If a concrete type has multiple lifetime interfaces then an <code>ArgumentException</code> will be thrown with a message that tells you of the problematic class that needs fixing</p>"},{"location":"Auto%20Registration/02-fromAssemblies/","title":"Auto registration from assemblies","text":"<p>The following example will automatically register services for the entry point assembly:</p> <pre><code>var services = new ServiceCollection()\n    .AutoRegisterServices(Assembly.GetEntryAssembly());\n</code></pre>"},{"location":"Auto%20Registration/03-fromTypes/","title":"Auto registration from types","text":"<p>The following example shows auto registration of types from the assemblies of the given types:</p> <pre><code>new ServiceCollection()\n    .AutoRegisterServicesFromAssembliesOfTypes(new[] { typeof(Program) });\n</code></pre>"},{"location":"Auto%20Registration/04-fromAType/","title":"Auto registration from a type","text":"<p>The following example shows auto registration of types from the assembly of the given type:</p> <pre><code>new ServiceCollection()\n    .AutoRegisterServicesFromAssemblyOf&lt;AutoRegisterServicesTests&gt;();\n</code></pre>"},{"location":"Auto%20Registration/05-multipleLifeTimesError/","title":"Auto registration with multiple lifetimes","text":"<p>The following example shows auto registration failing due to a class having multiple lifetimes:</p> <pre><code>new ServiceCollection()\n    .AutoRegisterServicesFromAssemblyOf&lt;Program&gt;();\n</code></pre> <p>The dependent interfaces and classes are defined as follows:</p> <pre><code>public interface IMyClass\n{\n    void SayHello(string name);\n}\n\npublic class MyClass : IMyClass, IScopedService, ISingletonService\n{\n    public void SayHello(string name) =&gt; Console.WriteLine($\"Hello {name}\");\n}\n</code></pre>"},{"location":"Intercepting%20Decorators/01-overview/","title":"Overview of intercepting decorators","text":"<p>Scrutor provides great <code>Decorator</code> functionality but sometimes a more Aspect Oriented Programming paradigm is needed.</p> <p>Castle.Core provides great interception capabilities that this method utilises.</p> <p>This section provides documentation for using the various methods of registering decorating interceptors.</p> <p>Note</p> <p>Open generics can be used via the <code>DecorateWithInterceptors</code> extension method for an <code>IServiceCollection</code></p>"},{"location":"Intercepting%20Decorators/01-syncInterceptor/","title":"DecorateWithInterceptor","text":""},{"location":"Intercepting%20Decorators/01-syncInterceptor/#example","title":"Example","text":"<p>Given definitions for the following in an assembly:</p> <p>NOTE: The following example expects that an <code>IConsole</code> implementation is registered in the <code>IServiceCollection</code> See LSL.AbstractConsole for an implementation that can be used with  an <code>IServiceCollection</code> via the LSL.AbstractConsole.ServiceProvider  package.</p> <pre><code>public interface ISyncServiceToDecorate\n{\n    void DoSomething();\n}\n\npublic class SyncServiceToDecorate : ISyncServiceToDecorate\n{\n    private readonly IConsole _console;\n\n    public SyncServiceToDecorate(IConsole console) =&gt; _console = console;\n\n    public void DoSomething() =&gt; _console.WriteLine(\"Something done\");\n}\n\npublic class MyInterceptor : IInterceptor\n{\n    private readonly IConsole _console;\n\n    public MyInterceptor(IConsole console) =&gt; _console = console;\n\n    public void Intercept(IInvocation invocation)\n    {\n        _console.WriteLine($\"Before invoke of {invocation.Method.Name}\");\n        invocation.Proceed();\n        _console.WriteLine($\"After invoke of {invocation.Method.Name}\");\n    }\n}\n</code></pre> <p>Then we can easily register a decorator with the provided interceptor as follows:</p> <pre><code>services\n    .AddInterceptorsFromAssemblyOf&lt;MyInterceptor&gt;()\n    .AddAbstractConsole()\n    .AddScoped&lt;ISyncServiceToDecorate, SyncServiceToDecorate&gt;()\n    .DecorateWithInterceptor&lt;ISyncServiceToDecorate, MyInterceptor&gt;();\n</code></pre> <p>Now we can just inject an <code>ISyncServiceToDecorate</code> and get <code>MyInterceptor</code> to intercept every call on it.</p> <p>If using the aforementioned <code>IConsole</code> implementation, then a class that consumes <code>ISyncServiceToDecorate</code> as shown below would get intercepted:</p> <pre><code>public class MyConsumer\n{\n    private readonly ISyncServiceToDecorate _syncServiceToDecorate;\n\n    public MyConsumer(ISyncServiceToDecorate syncServiceToDecorate) =&gt; \n        _syncServiceToDecorate = syncServiceToDecorate;\n\n    public void DoSomethingElse()\n    {\n        // This would result in an `IConsole`\n        // getting output of:\n        // Before invoke of 'DoSomething'\n        // Something done\n        // After invoke of 'DoSomething'\n        _syncServiceToDecorate.DoSomething();\n    }\n}\n</code></pre>"},{"location":"Intercepting%20Decorators/01-syncInterceptor/#example-with-multiple-interceptors","title":"Example with multiple interceptors","text":"<p>Using the classes in the previous example we can add a new interceptor to show  registration of multiple interceptors using a configuration delegate:</p> <pre><code>// Extra interceptor\npublic class MyOtherInterceptor : IInterceptor\n{\n    private readonly IConsole _console;\n\n    public MyInterceptor(IConsole console) =&gt; _console = console;\n\n    public void Intercept(IInvocation invocation)\n    {\n        _console.WriteLine($\"(Other) Before invoke of {invocation.Method.Name}\");\n        invocation.Proceed();\n        _console.WriteLine($\"(Other) After invoke of {invocation.Method.Name}\");\n    }\n}\n</code></pre> <p>The following code will then register both interceptors against our service:</p> <pre><code>services\n    .AddInterceptorsFromAssemblyOf&lt;MyInterceptor&gt;()\n    .AddAbstractConsole()\n    .AddScoped&lt;ISyncServiceToDecorate, SyncServiceToDecorate&gt;()\n    .DecorateWithInterceptor&lt;ISyncServiceToDecorate&gt;(c =&gt; c\n        .AddInterceptor&lt;MyInterceptor&gt;()\n        .AddInterceptor&lt;MyOtherInterceptor&gt;());\n</code></pre> <p>Now the following consumer code will result in extra logging:</p> <pre><code>public class MyConsumer\n{\n    private readonly ISyncServiceToDecorate _syncServiceToDecorate;\n\n    public MyConsumer(ISyncServiceToDecorate syncServiceToDecorate) =&gt; _syncServiceToDecorate = syncServiceToDecorate;\n\n    public void DoSomethingElse()\n    {\n        // This would result in an `IConsole`\n        // getting output of:\n        // (Other) Before invoke of 'DoSomething'\n        // Before invoke of 'DoSomething'\n        // Something done\n        // After invoke of 'DoSomething'\n        // (Other) After invoke of 'DoSomething'\n        _syncServiceToDecorate.DoSomething();\n    }\n}\n</code></pre>"},{"location":"Intercepting%20Decorators/02-asyncInterceptor/","title":"DecorateWithAsyncInterceptor","text":"<p>This method utilises the <code>IAsyncInterceptor</code> interface defined in Castle.Core.AsyncInterceptor. Please refer to the documentation there to see how to implement an <code>IAsyncInterceptor</code></p>"},{"location":"Intercepting%20Decorators/02-asyncInterceptor/#example","title":"Example","text":"<p>Given definitions for the following in an assembly:</p> <p>NOTE: The following example expects that an <code>IConsole</code> implementation is registered in the <code>IServiceCollection</code> See LSL.AbstractConsole for an implementation that can be used with  an <code>IServiceCollection</code> via the LSL.AbstractConsole.ServiceProvider  package.</p> <p>First we define an <code>IAsyncInterceptor</code></p> <pre><code>public class MyAsyncInterceptor : IAsyncInterceptor\n{\n    private readonly IConsole _console;\n\n    public MyAsyncInterceptor(IConsole console)\n    {\n        _console = console;\n    }\n\n    public void InterceptAsynchronous(IInvocation invocation)\n    {\n        invocation.ReturnValue = InternalInterceptAsynchronous(invocation);    \n    }\n\n    private async Task InternalInterceptAsynchronous(IInvocation invocation)\n    {\n        _console.WriteLine(\"Before invocation\");\n        invocation.Proceed();\n        var task = (Task)invocation.ReturnValue;\n        await task;\n\n        _console.WriteLine(\"After Invocation\");\n    }\n\n    public void InterceptAsynchronous&lt;TResult&gt;(IInvocation invocation)\n    {\n        // No need to implement as we only have \n        // one method with a Task return type\n        throw new System.NotImplementedException();\n    }\n\n    public void InterceptSynchronous(IInvocation invocation)\n    {\n        // No need to implement as we only have \n        // one method with a Task return type\n        throw new System.NotImplementedException();\n    }\n}\n</code></pre> <p>We then define a service (and it's interface) with an <code>async</code> method to intercept:</p> <pre><code>public interface IMyAsyncService\n{\n    Task RunAsync();\n}\n\npublic class MyAsyncService : IMyAsyncService\n{\n    private readonly IConsole _console;\n\n    public MyAsyncService(IConsole console)\n    {\n        _console = console;\n    }\n\n    public async Task RunAsync()\n    {\n        await Task.Delay(1000);\n        _console.WriteLine(\"My output\");\n    }\n}\n</code></pre> <p>We can then register the asynchronous interceptor as follows:</p> <pre><code>services\n    .AddInterceptorsFromAssemblyOf&lt;MyAsyncService&gt;()\n    .AddScoped&lt;IMyAsyncService, MyAsyncService&gt;()\n    .AddAbstractConsole()\n    .DecorateWithAsyncInterceptor&lt;IMyAsyncService, MyAsyncInterceptor&gt;();\n</code></pre> <p>We could also use the async decoration configuration method as follows:</p> <pre><code>services\n    .AddInterceptorsFromAssemblyOf&lt;MyAsyncService&gt;()\n    .AddScoped&lt;IMyAsyncService, MyAsyncService&gt;()\n    .AddAbstractConsole()\n    .DecorateWithAsyncInterceptors&lt;IMyAsyncService&gt;(\n        c =&gt; c.AddInterceptor&lt;MyAsyncInterceptor&gt;());\n</code></pre> <p>Both methods of registration end up doing the same thing. The first one is just a convenience method for less code.</p> <p>A consumer of this async service will then have the interceptor called on the service:</p> <pre><code>public class MyConsumer\n{\n    private readonly IMyAsyncService _serviceToDecorate;\n\n    public MyConsumer(IMyAsyncService serviceToDecorate) =&gt; _serviceToDecorate = serviceToDecorate;\n\n    public async Task DoSomethingElse()\n    {\n        // This would result in an `IConsole`\n        // getting output of:\n        // Before invocation\n        // My output\n        // After invocation\n        await _serviceToDecorate.RunAsync();\n    }\n}\n</code></pre>"}]}